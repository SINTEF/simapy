# This an autogenerated file
# 
# Generated with SignalFilterSetup
from typing import Dict,Sequence,List
from dmt.blueprint import Blueprint
from .blueprints.signalfiltersetup import SignalFilterSetupBlueprint
from typing import Dict
from ..sima import MOAO
from ..sima import ScriptableValue
from .filtering import Filtering

class SignalFilterSetup(MOAO):
    """
    Keyword arguments
    -----------------
    description : str
         (default "")
    scriptableValues : List[ScriptableValue]
    start : float
         (default 0.0)
    end : float
         (default 0.0)
    filtering : Filtering
         Filter signal using lower and upper cut off
    lowerCutoffFrequency : float
         (default 0.0)
    upperCutoffFrequency : float
         (default 0.0)
    showFullPath : bool
         Show full path when selecting signals(default False)
    """

    def __init__(self , description="", start=0.0, end=0.0, filtering=Filtering.NONE, lowerCutoffFrequency=0.0, upperCutoffFrequency=0.0, showFullPath=False, **kwargs):
        super().__init__(**kwargs)
        self.description = description
        self.scriptableValues = list()
        self.start = start
        self.end = end
        self.filtering = filtering
        self.lowerCutoffFrequency = lowerCutoffFrequency
        self.upperCutoffFrequency = upperCutoffFrequency
        self.showFullPath = showFullPath
        for key, value in kwargs.items():
            if not isinstance(value, Dict):
                setattr(self, key, value)


    @property
    def blueprint(self) -> Blueprint:
        """Return blueprint that this entity represents"""
        return SignalFilterSetupBlueprint()


    @property
    def description(self) -> str:
        """"""
        return self.__description

    @description.setter
    def description(self, value: str):
        """Set description"""
        self.__description = value

    @property
    def scriptableValues(self) -> List[ScriptableValue]:
        """"""
        return self.__scriptableValues

    @scriptableValues.setter
    def scriptableValues(self, value: List[ScriptableValue]):
        """Set scriptableValues"""
        if not isinstance(value, Sequence):
            raise ValueError("Expected sequense, but was " , type(value))
        self.__scriptableValues = value

    @property
    def start(self) -> float:
        """"""
        return self.__start

    @start.setter
    def start(self, value: float):
        """Set start"""
        self.__start = float(value)

    @property
    def end(self) -> float:
        """"""
        return self.__end

    @end.setter
    def end(self, value: float):
        """Set end"""
        self.__end = float(value)

    @property
    def filtering(self) -> Filtering:
        """Filter signal using lower and upper cut off"""
        return self.__filtering

    @filtering.setter
    def filtering(self, value: Filtering):
        """Set filtering"""
        self.__filtering = value

    @property
    def lowerCutoffFrequency(self) -> float:
        """"""
        return self.__lowerCutoffFrequency

    @lowerCutoffFrequency.setter
    def lowerCutoffFrequency(self, value: float):
        """Set lowerCutoffFrequency"""
        self.__lowerCutoffFrequency = float(value)

    @property
    def upperCutoffFrequency(self) -> float:
        """"""
        return self.__upperCutoffFrequency

    @upperCutoffFrequency.setter
    def upperCutoffFrequency(self, value: float):
        """Set upperCutoffFrequency"""
        self.__upperCutoffFrequency = float(value)

    @property
    def showFullPath(self) -> bool:
        """Show full path when selecting signals"""
        return self.__showFullPath

    @showFullPath.setter
    def showFullPath(self, value: bool):
        """Set showFullPath"""
        self.__showFullPath = bool(value)
