# This an autogenerated file
# 
# Generated with DistributionFilter
from typing import Dict,Sequence,List
from dmt.entity import Entity
from dmt.blueprint import Blueprint
from .blueprints.distributionfilter import DistributionFilterBlueprint
from sima.post.controlsignalinputslot import ControlSignalInputSlot
from sima.post.distribution import Distribution
from sima.post.inputslot import InputSlot
from sima.post.operationnode import OperationNode
from sima.post.outputslot import OutputSlot
from sima.post.peakextreme import PeakExtreme
from sima.sima.scriptablevalue import ScriptableValue

class DistributionFilter(OperationNode):
    """
    Keyword arguments
    -----------------
    name : str
         (default "")
    description : str
         (default "")
    _id : str
         (default "")
    scriptableValues : List[ScriptableValue]
    x : int
         (default 0)
    y : int
         (default 0)
    h : int
         (default 0)
    w : int
         (default 0)
    controlSignalInputSlots : List[ControlSignalInputSlot]
    filterInputSlots : List[InputSlot]
    filterOutputSlots : List[OutputSlot]
    renameOutput : bool
         (default True)
    distribution : Distribution
         Number of intervals used for sample distribution
    threshold : float
         Threshold for fitting. Upper threshold when minima and lower threshold when maxima(default 0.0)
    useReturnPeriod : bool
         Estimate return period value(default False)
    returnPeriod : float
         Return period(default 3.0)
    probabilityLevel : float
         Compute response corresponding to the given probabilityLevel(default 0.5)
    extreme : PeakExtreme
         Maxima or minima distribution
    transformAxis : bool
         Show output distribution in transformed axis(default False)
    """

    def __init__(self , name:str="", description:str="", _id:str="", x:int=0, y:int=0, h:int=0, w:int=0, renameOutput:bool=True, distribution:Distribution=Distribution.RAYLEIGH, threshold:float=0.0, useReturnPeriod:bool=False, returnPeriod:float=3.0, probabilityLevel:float=0.5, extreme:PeakExtreme=PeakExtreme.MAX, transformAxis:bool=False, **kwargs):
        super().__init__(**kwargs)
        self.__name = name
        self.__description = description
        self.___id = _id
        self.__scriptableValues = list()
        self.__x = x
        self.__y = y
        self.__h = h
        self.__w = w
        self.__controlSignalInputSlots = list()
        self.__filterInputSlots = list()
        self.__filterOutputSlots = list()
        self.__renameOutput = renameOutput
        self.__distribution = distribution
        self.__threshold = threshold
        self.__useReturnPeriod = useReturnPeriod
        self.__returnPeriod = returnPeriod
        self.__probabilityLevel = probabilityLevel
        self.__extreme = extreme
        self.__transformAxis = transformAxis
        for key, value in kwargs.items():
            if not isinstance(value, Dict):
                setattr(self, key, value)


    @property
    def blueprint(self) -> Blueprint:
        """Return blueprint that this entity represents"""
        return DistributionFilterBlueprint()


    @property
    def name(self) -> str:
        """"""
        return self.__name

    @name.setter
    def name(self, value: str):
        """Set name"""
        self.__name = str(value)

    @property
    def description(self) -> str:
        """"""
        return self.__description

    @description.setter
    def description(self, value: str):
        """Set description"""
        self.__description = str(value)

    @property
    def _id(self) -> str:
        """"""
        return self.___id

    @_id.setter
    def _id(self, value: str):
        """Set _id"""
        self.___id = str(value)

    @property
    def scriptableValues(self) -> List[ScriptableValue]:
        """"""
        return self.__scriptableValues

    @scriptableValues.setter
    def scriptableValues(self, value: List[ScriptableValue]):
        """Set scriptableValues"""
        if not isinstance(value, Sequence):
            raise Exception("Expected sequense, but was " , type(value))
        self.__scriptableValues = value

    @property
    def x(self) -> int:
        """"""
        return self.__x

    @x.setter
    def x(self, value: int):
        """Set x"""
        self.__x = int(value)

    @property
    def y(self) -> int:
        """"""
        return self.__y

    @y.setter
    def y(self, value: int):
        """Set y"""
        self.__y = int(value)

    @property
    def h(self) -> int:
        """"""
        return self.__h

    @h.setter
    def h(self, value: int):
        """Set h"""
        self.__h = int(value)

    @property
    def w(self) -> int:
        """"""
        return self.__w

    @w.setter
    def w(self, value: int):
        """Set w"""
        self.__w = int(value)

    @property
    def controlSignalInputSlots(self) -> List[ControlSignalInputSlot]:
        """"""
        return self.__controlSignalInputSlots

    @controlSignalInputSlots.setter
    def controlSignalInputSlots(self, value: List[ControlSignalInputSlot]):
        """Set controlSignalInputSlots"""
        if not isinstance(value, Sequence):
            raise Exception("Expected sequense, but was " , type(value))
        self.__controlSignalInputSlots = value

    @property
    def filterInputSlots(self) -> List[InputSlot]:
        """"""
        return self.__filterInputSlots

    @filterInputSlots.setter
    def filterInputSlots(self, value: List[InputSlot]):
        """Set filterInputSlots"""
        if not isinstance(value, Sequence):
            raise Exception("Expected sequense, but was " , type(value))
        self.__filterInputSlots = value

    @property
    def filterOutputSlots(self) -> List[OutputSlot]:
        """"""
        return self.__filterOutputSlots

    @filterOutputSlots.setter
    def filterOutputSlots(self, value: List[OutputSlot]):
        """Set filterOutputSlots"""
        if not isinstance(value, Sequence):
            raise Exception("Expected sequense, but was " , type(value))
        self.__filterOutputSlots = value

    @property
    def renameOutput(self) -> bool:
        """"""
        return self.__renameOutput

    @renameOutput.setter
    def renameOutput(self, value: bool):
        """Set renameOutput"""
        self.__renameOutput = bool(value)

    @property
    def distribution(self) -> Distribution:
        """Number of intervals used for sample distribution"""
        return self.__distribution

    @distribution.setter
    def distribution(self, value: Distribution):
        """Set distribution"""
        self.__distribution = value

    @property
    def threshold(self) -> float:
        """Threshold for fitting. Upper threshold when minima and lower threshold when maxima"""
        return self.__threshold

    @threshold.setter
    def threshold(self, value: float):
        """Set threshold"""
        self.__threshold = float(value)

    @property
    def useReturnPeriod(self) -> bool:
        """Estimate return period value"""
        return self.__useReturnPeriod

    @useReturnPeriod.setter
    def useReturnPeriod(self, value: bool):
        """Set useReturnPeriod"""
        self.__useReturnPeriod = bool(value)

    @property
    def returnPeriod(self) -> float:
        """Return period"""
        return self.__returnPeriod

    @returnPeriod.setter
    def returnPeriod(self, value: float):
        """Set returnPeriod"""
        self.__returnPeriod = float(value)

    @property
    def probabilityLevel(self) -> float:
        """Compute response corresponding to the given probabilityLevel"""
        return self.__probabilityLevel

    @probabilityLevel.setter
    def probabilityLevel(self, value: float):
        """Set probabilityLevel"""
        self.__probabilityLevel = float(value)

    @property
    def extreme(self) -> PeakExtreme:
        """Maxima or minima distribution"""
        return self.__extreme

    @extreme.setter
    def extreme(self, value: PeakExtreme):
        """Set extreme"""
        self.__extreme = value

    @property
    def transformAxis(self) -> bool:
        """Show output distribution in transformed axis"""
        return self.__transformAxis

    @transformAxis.setter
    def transformAxis(self, value: bool):
        """Set transformAxis"""
        self.__transformAxis = bool(value)
